# -*- coding: utf-8 -*-
"""delaunay_st.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PIJahJpL5Maplel_MVSiyAAq3McHMi6z
"""

import os
import numpy as np
import matplotlib.pyplot as plt

def lcg(seed=42, a=21, c=43, m=200, n=20):
    numbers = []
    x = seed
    for _ in range(n):
        x = (a * x + c) % m
        numbers.append(x)
    return numbers

def get_points(points_2_pairs=20):
    points = {
        'points_1': np.array([
                    [120, 240],
                    [370, 180],
                    [550, 460],
                    [260, 540]
                    ]),
        'points_2': np.reshape(np.array(lcg(n=2*points_2_pairs)),(-1,2))
    }
    return points

import numpy as np
import matplotlib.pyplot as plt

class DelaunayTriangulation:
    def __init__(self, points):
        self.points = points
        self.triangles = []

    # 주어진 점이 삼각형의 외접원에 포함되는지 확인하는 함수
    def circumcircle_contains(self, tri, p):
        ax, ay = self.points[tri[0]]  # 삼각형의 첫 번째 점
        bx, by = self.points[tri[1]]  # 삼각형의 두 번째 점
        cx, cy = self.points[tri[2]]  # 삼각형의 세 번째 점
        dx, dy = p  # 테스트할 점

        # 외접원을 정의하는 행렬식 계산
        mat = np.array([
            [ax - dx, ay - dy, (ax - dx)**2 + (ay - dy)**2],
            [bx - dx, by - dy, (bx - dx)**2 + (by - dy)**2],
            [cx - dx, cy - dy, (cx - dx)**2 + (cy - dy)**2]
        ])

        det = np.linalg.det(mat)  # 행렬식 계산

        # 삼각형의 방향(반시계/시계)을 판별
        orientation = ((bx - ax) * (cy - ay) - (by - ay) * (cx - ax))
        if orientation > 0:  # 반시계 방향일 때
            return det > 0  # 행렬식이 양수이면 포함됨
        else:  # 시계 방향일 때
            return det < 0  # 행렬식이 음수이면 포함됨

    # 델로네 삼각분할 생성 함수
    def makeDelaunay(self):
        # 초삼각형 (Super Triangle) 생성
        min_x = np.min(self.points[:, 0])  # 점들의 최소 x값
        max_x = np.max(self.points[:, 0])  # 점들의 최대 x값
        min_y = np.min(self.points[:, 1])  # 점들의 최소 y값
        max_y = np.max(self.points[:, 1])  # 점들의 최대 y값

        dx = max_x - min_x  # x축의 범위
        dy = max_y - min_y  # y축의 범위
        delta_max = max(dx, dy) * 10  # 더 큰 범위로 초삼각형 크기 조정

        mid_x = (min_x + max_x) / 2  # x 중심
        mid_y = (min_y + max_y) / 2  # y 중심

        # 초삼각형의 꼭짓점 좌표 계산
        p1 = np.array([mid_x - delta_max, mid_y - delta_max])
        p2 = np.array([mid_x, mid_y + delta_max])
        p3 = np.array([mid_x + delta_max, mid_y - delta_max])

        # 초삼각형의 인덱스 추가
        n_points = len(self.points)
        self.points = np.vstack([self.points, p1, p2, p3])  # 점 집합에 초삼각형의 꼭짓점 추가
        super_triangle = [n_points, n_points + 1, n_points + 2]  # 초삼각형의 인덱스
        self.triangles = [super_triangle]  # 초기 삼각형 리스트에 초삼각형 추가

        # 각 점을 삽입하여 삼각형을 구성
        for idx in range(n_points):
            point = self.points[idx]  # 현재 점
            bad_triangles = []  # 외접원에 포함되는 bad_triangles
            polygon = []  # 경계 다각형

            # 외접원에 점을 포함하는 bad_triangles 찾기
            for tri in self.triangles:
                if self.circumcircle_contains(tri, point):
                    bad_triangles.append(tri)

            # 에지 카운트 및 경계 에지 찾기
            edge_count = {}
            for tri in bad_triangles:
                for i in range(3):
                    edge = tuple(sorted([tri[i], tri[(i + 1) % 3]]))
                    if edge in edge_count:
                        edge_count[edge] += 1
                    else:
                        edge_count[edge] = 1

            for edge, count in edge_count.items():
                if count == 1:  # 경계 에지
                    polygon.append(edge)

            # bad_triangles 제거
            self.triangles = [tri for tri in self.triangles if tri not in bad_triangles]

            # 새로운 삼각형 생성
            for edge in polygon:
                new_triangle = [edge[0], edge[1], idx]
                self.triangles.append(new_triangle)

        # 초삼각형에 연결된 삼각형 제거
        self.triangles = [tri for tri in self.triangles if all(v < n_points for v in tri)]

        # 초삼각형의 꼭짓점 제거
        self.points = self.points[:n_points]  # 초삼각형 꼭짓점 제거

    def plot(self):
        fig, ax = plt.subplots()

        for triangle in self.triangles:
            vertices = self.points[triangle]
            x = np.append(vertices[:, 0], vertices[0, 0])
            y = np.append(vertices[:, 1], vertices[0, 1])
            ax.plot(x, y, 'k-')

        ax.scatter(self.points[:, 0], self.points[:, 1], color='red', zorder=2)

        ax.set_aspect('equal')
        plt.axis('off')
        plt.show()

# Example usage
points_1, points_2 = get_points().values()
dt = DelaunayTriangulation(points_1)
dt.makeDelaunay()
dt.plot()

dt = DelaunayTriangulation(points_2)
dt.makeDelaunay()
dt.plot()

from scipy.spatial import Delaunay


class DelaunayTriangulation:
    def __init__(self, points):
        self.points = points
        self.tri = Delaunay(points)

    def plot(self):
        fig, ax = plt.subplots()

        # 삼각형 그리기
        for triangle in self.tri.simplices:
            vertices = self.points[triangle]
            x = np.append(vertices[:, 0], vertices[0, 0])
            y = np.append(vertices[:, 1], vertices[0, 1])
            ax.plot(x, y, 'k-')

        # 점 그리기
        ax.scatter(self.points[:, 0], self.points[:, 1], color='red', zorder=2)

        ax.set_aspect('equal')
        plt.axis('off')  # 축 제거
        plt.show()

points = np.array([
    [120, 240],
    [370, 180],
    [550, 460],
    [260, 540]
])


points_1, points_2 = get_points().values()
dt = DelaunayTriangulation(points_1)
dt.plot()

dt = DelaunayTriangulation(points_2)
dt.plot()

points_1, points_2 = get_points().values()
plt.triplot(points_2[:,0],points_2[:,1])