# -*- coding: utf-8 -*-
"""ps_monte_carlo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EXgbvK3Hcdv5iPhavPjSMWYteLq1_cF8

# 코드 예시) Random 함수
"""

import random

#random.random() -> 0.0에서 1.0사이의 실수 중에서 난수값 리턴
print(random.random())
# ex) 0.2664520652284096

#random.uniform(a, b) -> 괄호 안 두 수 사이의 실수 중에서 난수값을 리턴
print(random.uniform(10, 30))
# ex) 28.038707445386397

#random.randint(a, b) -> 괄호 안 두 수 사이의 정수 중에서 난수값을 리턴
print(random.randint(100,200))
# ex) 106

#random.choice(sample) 함수 -> sample에서 무작위로 하나를 선택하여 리턴
data = [1, 2, 3, 4, 5, 6, 7]
print(random.choice(data))
# ex) 5

#random.sample(sample, n) -> 입력으로 받은 sample 에서 정한 개수만큼  무작위로 뽑아 리턴함
data = [1, 2, 3, 4, 'apple', 'banna']
print(random.sample(data, 3))
# ex) ['apple', 2, 3]
print(random.sample(data, 3))
# ex) ['apple', 3, 'banna']
print(random.sample(data, 5))
# ex) [2, 3, 1, 'apple', 4]

"""# 실습1. 난수 히스토그램 그리기(파이썬 random 모듈)"""

# import packages
import matplotlib.pyplot as plt
from tqdm import tqdm # optional
import random

# 100번 수행
num_iterations = 100
random_integers = []

## write answer


for _ in range(num_iterations):
  random_integers.append(random.randint(0,99))


fig = plt.figure()
plt.hist(random_integers)
plt.title(f"Check Uniform Distribution of {num_iterations} iterations")
plt.xlabel("Numbers")
plt.ylabel("N of each number")
plt.xlim([0, 99])
plt.show()

"""# 실습 2. Linear Congruential Generator(LCG) 구현  

X_(n+1) = (aX_n+C) mod m

LCG는 다음과 같은 인자들로 유일하게 결정됨  
  - 0 < m, 0 < a < m, 0 <= c < m, 0<=초기값 < m  

최대 주기 m을 가지기 위한 필요충분조건  

  - c와 m이 서로소, a-1이 m의 모든 소인수로 나뉨
  - m이 4의 배수면 a-1도 4의 배수
"""

def lcg(seed, loop, m=2**32, a=214013, c=2531011):
    for i in range(loop):
        # write answer
        seed = (a * seed + c) % m
        yield seed

num_iterations = 100
random_generator = lcg(seed=13, loop=num_iterations, m=2**32)
random_integers = []

## write answer
for i in random_generator:
    random_integers.append(i)

fig = plt.figure()
plt.hist(random_integers)
plt.title(f"Check Uniform Distribution of {num_iterations} iterations")
plt.xlabel("Numbers")
plt.ylabel("N of each number")
plt.xlim([0, 2**32])
plt.show()

"""# 실습 2-2 난수들 중 Uniform Distribution 확인  

"""

# LCG
# 평균을 구할 때 numpy함수를 사용해도 되고, 직접 구현해도 됨.
# lcg는 0~255 난수 생성
# 메르센 트위스터는 0~100 난수 생성
from collections import defaultdict
import numpy as np

for num_iterations in [1000,10000,100000]:
    ## write answer
    random_generator = lcg(seed=13, loop=num_iterations, m=256)
    frequency=defaultdict(int)
    for i in random_generator:
        frequency[i] += 1
    counts = np.array([frequency[i] for i in range(256)])
    expected_frequency = num_iterations / 256
    errors = np.abs(counts - expected_frequency)
    average_error = np.mean(errors)/(num_iterations)

    print(f"메르센 트위스터 시행횟수 {num_iterations}에서의 uniform distribution 오차 : {average_error}")

# 메르센 트위스터
from collections import defaultdict
import numpy as np

for num_iterations in [1000,10000,100000]:
    ## write answer
    frequency=defaultdict(int)

    for _ in range(num_iterations):
        i = random.randint(0, 100)
        frequency[i] += 1


    counts = np.array([frequency[i] for i in range(101)])
    expected_frequency = num_iterations / 101
    errors = np.abs(counts - expected_frequency)
    average_error = np.mean(errors)/(num_iterations)

    print(f"메르센 트위스터 시행횟수 {num_iterations}에서의 uniform distribution 오차 : {average_error}")

"""# 실습 3. 주사위 합이 8인 경우"""

# 출력시 컬러 지원 가능 모듈 설치
import random
!pip install termcolor
from termcolor import colored
!pip install colorama
from colorama import init, Fore, Back, Style

def roll_dice():
    ## write answer
    dice_1 = random.randint(1, 6)
    dice_2 = random.randint(1, 6)

    if dice_1 + dice_2 == 8:
      return (dice_1, dice_2, "hit!",1)
    else :
      return (dice_1, dice_2, "", 0)

dice_tries = []
num_iterations = 100
hits = 0
for _ in range(num_iterations):
## write answer
  dice_try=roll_dice()
  dice_tries.append(dice_try)
print("="*100)
print(Fore.RED + "* 두 주사위의 합이 8인 경우에는 cyan 색의 음영이 들어가 있음 *" + Style.RESET_ALL)

for i in range(num_iterations):
  if(i>0) and ((i-4)%5)==0:
      if dice_tries[i][2] == "hit!":
        print(Back.CYAN + Fore.YELLOW + f"try {i : 2d} :  {dice_tries[i][0]} {dice_tries[i][1]}"+Style.RESET_ALL, end="\n")
      else :
        print(f"try {i:2d} : {dice_tries[i][0]} {dice_tries[i][1]}", end="\n")
  else:
      if dice_tries[i][2] == "hit!":
        print(Back.CYAN + Fore.YELLOW + f"try {i : 2d} :  {dice_tries[i][0]} {dice_tries[i][1]}"+Style.RESET_ALL, end=" ")
      else :
        print(f"try {i:2d} : {dice_tries[i][0]} {dice_tries[i][1]}", end=" ")

  hits += dice_tries[i][3]

print(colored("\n실제 값 : 0.138889", "red"))
print(colored(f"계산된 값 : {round(hits / num_iterations,6)}", "red"))
print(colored(f"오차율 : {abs(hits / num_iterations - 5/36) / (5/36) * 100} %", "red"))
print("="*100)

